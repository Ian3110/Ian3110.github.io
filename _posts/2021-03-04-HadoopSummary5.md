---
layout: post
title: "맵리듀스(Map Reduce) 프레임워크"
categories:
- Hadoop
---

### 본격적인 맵리듀스 동작을 보기 전 알아 두면 좋은 것
-	맵리듀스 프레임워크는 **Map**, **Shuffle & Sort**, **Reduce** 단계를 거쳐서 입력된 **잡(Job)**을 분할해 가며 처리를 진행함.
-	맵리듀스 잡은 복수의 **태스크(Task)**로 분할됨. 맵 태스크와 리듀스 태스크는 각각 병렬로 처리될 수 있음.
-	맵 태스크 수와 리듀스 태스크 수는 동일할 필요가 없음.
-	리듀스 처리는 맵 처리의 출력을 받기 전까지는 시작될 수 없음.
-	맵 -> 셔플&소트 -> 리듀스 작업은 순차적으로 진행됨.
-	맵리듀스 잡의 최종 결과는 HDFS에 출력됨. 리듀스 처리를 통한 집약 처리가 필요 없다면 맵 처리만으로도 작업이 끝날 수 있음.<br/><br/><br/><br/>

## 맵리듀스 단계별 동작
---
### 1)	맵(Map) 처리
-	맵 처리의 입력 데이터를 ‘**스플릿(Input Split : 입력 스플릿)**’이라고 하는데 입력 데이터는 HDFS 파일이어야 하기에 **스플릿 크기=블록 크기**가 되어야 함(필요에 따라 스플릿 크기<블록 크기로 조정이 가능함).<br/><br/>
-	스플릿에서 **key-value**를 해석하고, 레코드를 하나씩 읽어 들여 맵으로 처리함.<br/><br/>
-	사용자가 정의한 **맵 처리**는 **Mapper**를 통해 실현됨. 이때 입력 데이터와 출력 데이터 모두 key-value 쌍을 이룸. 출력 데이터는 key로 정렬됨.<br/><br/>
-	맵의 출력 값은 **partitioner**를 통하여 사용자가 정의한 리듀스 처리를 하는 Reducer에서 전달됨. partitioner로 리듀서 처리에 전달할 데이터 분할 방법을 정할 수 있음.<br/><br/>
-	**컴바이너(Combiner)**: 하둡에서는 맵 처리 직후에 컴바이너 처리를 정의할 수 있음. 셔플 단계에 데이터를 전달하기전에 로컬 상에서 데이터를 집약하는 역할을 함. 셔플 단계에서의 통신 량을 줄여주는 효과가 있음.<br/><br/><br/>

### 2)	셔플 & 소트(Shuffle & Sort) 처리
-	맵 출력이 리듀서까지 전달되는 일련의 과정을 셔플&소트 처리라고 함.<br/><br/>
-	보통 **리듀스 처리** 노드는 맵 처리를 하는 노드들에 포함되는 경우가 많은데 이 경우에는 노드간 데이터 통신이 발생하지 않음. 그러나 리듀스 처리 노드와 맵 처리 노드가 다르다면 HTTP 데이터 통신이 발생함.<br/><br/>
-	노드 수가 많은 대규모 클러스터에서 대용량 데이터를 처리할 때 대량의 네트워크 통신을 발생시켜 맵 리듀스 처리 전체의 성능 저하를 초래할 수 있으니 주의해야함.<br/><br/>
-	맵 출력 결과는 partitioner에 따라 목적지 Reducer가 정해짐.<br/><br/>
-	Reducer가 Mapper의 모든 데이터를 받으면 리듀스 태스크 처리가 가능하도록 입력을 하나로 모음.<br/><br/> 
-	각 Reducer는 여러 Mapper들로부터 데이터 조각들을 받기에, 이를 다시 **병합-정렬 집약**함. 이를 통해 리듀스 태스크 입력은 key별로 정렬된 상태가 됨.<br/><br/><br/>

### 3)	Reduce 처리
-	같은 key로 모아진 중간 데이터(value 집합)에 대해 사용자가 정의한 리듀스 처리를 실행함. 리듀스 처리의 입력을 **‘파티션’**이라고 함.<br/><br/>
-	**리듀스**는 새로운 key-value 쌍을 생성하고 출력함.<br/><br/><br/>

## 맵리듀스 아키텍처
---
### 노드 구성
-	**잡(Job)과 태스크(Task)**: 사용자가 투입한 잡은 맵리듀스 프레임워크 내에서 여러 태스크로 분할하여 처리됨. 잡은 맵리듀스의 처리 단위. 태스크는 맵 처리나 리듀스 처리에 할당되는 처리 단위.<br/><br/>
-	맵리듀스 프레임워크에서 마스터 노드를 **잡 트래커(Job Tracker)**라고 하며 슬레이브 노드를 **태스크 트래커(Task Tracker)**라고 함.<br/><br/>
-	일반적으로 태스크 트래커와 HDFS의 슬레이브 노드인 데이터 노드는 물리적으로 같은 장비에 설치됨. 태스크 트래커가 먼저 로컬 데이터 노드상의 데이터에 대해 잡을 실행하기에 네트워크 통신을 발생시키지 않고 높은 성능을 낼 수 있음.<br/><br/>
-	맵리듀스에 잡을 투입하는 클라이언트를 **잡 클라이언트(Job Client)**라고 함. 잡 클라이언트는 잡 트래커에게 잡 의뢰, 잡 우선순위 변경, 잡 강제 종료를 요청할 수 있음. 잡 트래커는 잡 클라이언트에게 잡 진행 상황 보고, 잡 완료 통지를 함.<br/><br/>
-	하나의 잡 트래커로 하둡 클러스터 상에서 동작하는 모든 맵 리듀스 잡을 관리함. 하나의 잡 트래커에 대해 복수의 태스크 트래커가 협력하여 동작함.<br/><br/><br/>

### 잡 트래커의 역할
**1)	잡 관리**<br/>
- 맵 태스크 할당 제어: 잡 클라이언트가 보낸 분할 정보를 파악하여 맵 태스크 할당을 제어함.<br/><br/>
- 맵 처리 결과 파악: 리듀스 처리에서 이용할 수 있는 맵 처리 결과 정보를 파악함.<br/><br/>
- 잡 진행 통지: 실행 중인 맵리듀스 잡의 진행 상황을 정기적으로 잡 클라이언트에 통지함.<br/><br/>

**2)	리소스 관리**<br/>
- 처리 할당: 맵 처리나 리듀스 처리를 태스크 트래커에 할당함.<br/><br/>
- 처리의 주기적 실행: 같은 태스크를 여러 태스크 트래커로 병렬 실행시켜 가장 빨리 얻은 결과를 사용하도록 처리를 할당함.<br/><br/>
- 처리 재할당: 태스크 트래커에 이상이 발생하여 처리가 진행되지 않을 때, 다른 태스크 트래커에 처리를 재할당함.<br/><br/>
- 블랙리스트화: 처리 실패 빈도가 높은 태스크 트래커에 처리를 할당하지 않음.<br/><br/>
- 태스크 트래커 추가/제외<br/><br/>

**3)	잡 실행 이력 관리**<br/>
- 맵리듀스 잡의 실행 상태를 관리하고 이력을 저장해서 잡을 분석함.<br/><br/><br/>


## 태스크 트래커의 역할
-	Child 프로세스 생성과 처리 실행: 잡 트래커가 할당한 맵 처리와 리듀스 처리에 대해 실제 처리를 진행하는 child 프로세스를 생성하고 실행시킴.<br/><br/>
-	Child 프로세스 상태 확인: Child 프로세스 진행 상태 관리하며 잡 트래커에 상황을 정기적으로 통지함.<br/><br/>
-	처리 중지 통지: 잡 트래커로부터 처리 중지 지시가 오면 해당 처리를 멈춤.<br/><br/>
-	하트비트 통신: 자신이 동작하고 있다는 것을 전달하기 위해 잡 트래커에 정기적으로 하트비트를 전송함.<br/><br/>
-	맵 처리 수와 리듀스 처리 수 파악: 어느 한 시점의 맵 처리 수나 리듀스 처리 수를 파악함. 사전에 정의해 둔 최대 동시 실행 수에 미치지 않는다면 잡 트래커에게 처리 유무를 물음.<br/><br/><br/>

## 잡 클라이언트의 역할
-	입력 데이터의 분할 방침 결정: 입력 데이터를 어떻게 분할하고 병렬 처리할 것인 것 결정함.<br/><br/>
-	잡 의뢰: 잡 트래커에게 맵리듀스 잡 실행 의뢰함.<br/><br/>
-	애플리케이션 배포: 맵리듀스 잡을 실행하기 위한 애플리케이션을 HDFS에 저장함.<br/><br/>
-	진행 상태 수신: 잡 트래커가 보내준 잡 실행 상태를 수신함.<br/><br/>
-	잡 관리: 사용자 단위로 맵리듀스 잡을 관리함. 맵리듀스 잡의 우선 순위를 변경하거나 강제 종료함.<br/><br/><br/>



*쉽게 쉽게 써볼까나 히히 근데 그게 더 어려워ㅓㅓㅓ*
